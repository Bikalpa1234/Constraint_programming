# -*- coding: utf-8 -*-
"""
Created on Mon Sep 14 23:18:29 2020


import numpy as np
from itertools import product
import constraint






def one(n=10):
    """
    0<x<4 
    0<y<=10 
    x->int y->int
    x+y>=5
    """
    
    pro=constraint.Problem()
    pro.addVariable('x', range(1,4))
    pro.addVariable('y', range(1,n+1))
    pro.addConstraint(lambda x: x==1 or x==2 or x==3, 'x')
    pro.addConstraint(lambda x,y: x+y>=5,['x','y'])
    sol = pro.getSolutions()
    return sol

    

def two():
    """
    Project Euler 1
    “If we list all the natural numbers below 10 that are multiples of
    3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.”
    How can we transform this into an executable specification?
    """
    pro=constraint.Problem()
    pro.addVariables('a', range(0,1001))
    pro.addConstraint(lambda x: x%3==0 or x%5==0,'a')
    sol=pro.getSolutions()
    return sum([x['a'] for x in sol])

def three():
    """
    “Each new term in the Fibonacci sequence is generated by adding 
    the previous two terms. By starting with 1 and 2, the first 10 
    terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering
    the terms in the Fibonacci sequence whose values do not exceed four 
    million, find the sum of the even-valued terms.”

    """
    pro=constraint.Problem()
    def fibGen(n, x=1, y=2):
        a,b=x,y
        while a<=n:
            yield a
            a,b,n=b,a+b,n-1
    r=[i for i in fibGen(4*10**6)]
    pro.addVariable('a', r)
    pro.addConstraint(lambda x: x%2==0,'a')
    sol=pro.getSolutions()
    return sum([x['a'] for x in sol])
        
    
def four(n):
    """
    Find the largest prime factor of a number 600851475143.
    python_constraint cant handle that number.
    """
    def is_prime(num):
        i=2
        while i<=num**0.5:
            if num%i==0:
                return False
            i+=1
        return True
    pro=constraint.Problem()
    pro.addVariable('a', range(2,n+1))
    pro.addConstraint(is_prime, 'a')
    pro.addConstraint(lambda x: n%x==0,'a')
    sol=pro.getSolutions()

    return max([x['a'] for x in sol])
